---
title: react学习
---

### reactjs

react 构建用户界面的 javascript库，主要用于构建UI界面，源起 Facebook的Instagram,2013年开源

## 特点
1. 声明式的设计
2. 高效，采用虚拟dom来实现 dom的渲染，最大限度的减少 dom 的操作
3. 灵活，跟其他库灵活配合使用
4. **JSX**， 俗称 在 js中 写 html, javascript 语法的扩展
5. 组件化，模块化。代码容易复用，大型项目非常喜欢react
6. 单向数据流，没有实现数据的双向绑定。 数据->视图->事件->数据

## 创建项目
[react官网](https://react.docschina.org/)

1. 通过javascript引入使用，仅用于学习调试使用
``` js
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
``` 
2. 通过react的脚手架，创建项目，进行开发，部署
   1. 安装脚手架 Create react App
   ```
   cnpm install -g create-react-app
   ```
   2. 创建项目
   ```
   create-react-app xxxx(项目名称自定义)
   cd xxxx
   npm start
   ```

## react元素渲染
``` jsx
这里不需要加引号
let h1 = <h1>helloworld</h1>
使用JSX的语法，可以创建JS元素对象
注意：JSX元素对象，或者组件，必须只有1个根元素(根节点)
```
   1. 函数式组件渲染
   ``` jsx
   // 实时页面时间显示
   function clock() {
     let time = new Date().toLocaleTimeString();
     let element = <h1>现在的时间是{time}</h1>
     let root = document.querySelector('#root');
     ReactDOM.render(element, root);
   }
   setInterval(clock, 1000);
   ```
   ``` jsx
   function clock2(props) {
   return (
       <div>
          <h1>现在的时间是 {props.data.toLocaleTimeString()}</h1>
          <h1>函数式组件开发</h1>
      </div>
   );
   }
   function run() {
   ReactDOM.render(
      <clock2 data={new Date()} />,
      document.querySelector('#root')
   );
   }
   setInterval(run, 1000);
   ```

### react JSX
1. 优点：
   1. JSX执行更快，编译为Javascript代码时进行优化
   2. 类型更安全，编译过程如果出错，就不能继续编译下去，及时发现错误
   3. JSX编写模板更加简单快速(这里咱不和VUE比)

注意：
1. JSX必须要有根节点
2. 正常的普通HTML元素要小写，如果大写，默认被认为是组件   

### JSX表达式
1. 由HTML元素构成
2. 中间如果需要插入变量，用`{}`
3. `{}`中间可以使用表达式
4. `{}`中间 表达式中 可以使用JSX对象
5. 属性和HTML内容一样都是用`{}`来插入 

`注意：一个{} 只能有一个表达式，如果需要多个表达式，使用多个{}`
`但是一个{}中 可以层层嵌套表达式 `

``` jsx
let main= '下雨';
let element = (
  <div>
    <span>{main == '下雨' ? <bottom>唱跳 Rap</bottom> : <bottom>打篮球<bottom/>}</span>
  </div>
);
ReactDOM.render(element, document.querySelector('#root'));
```

``` jsx
let color= 'bgRed'; // 引入一个css,设置 类名为 bgRed 的类
let element = (
  <div className={color}>123</div>
);
ReactDOM.render(element, document.querySelector('#root'));
```

## jsx style
``` jsx
let exampleStyle = {
  background: "skyblue",
  borderBottom: "1px solid red",
  'background-image':'url(https://xxxxxx.jpg)'
};

let element = (
  <div>
    {/* 这里写注释 */}
    <h1 style={exampleStyle}>helloworld</h1>
  </div>
);
ReactDOM.render(element, document.querySelector('#root'));
```
``` jsx
let classStr = "redBg"; // ['aaa', 'bbb'].join(' '); 只能是字符串传进去
let element2 = (
  <div>
    {/* 这里写注释 */}
    <h1 className={'class1 ' + classStr}>多个类名</h1>
  </div>
);
ReactDOM.render(element2, document.querySelector('#root'));
```
1. class中，不可以存在多个 class
``` jsx
错误表示： <div class='aaa' class={'bbb'}>123</div>
```
2. style样式中，如果存在多个单词属性的组合，第二个单词开始，首字母大写,或者引号引起来，否则报错
``` jsx
let exampleStyle = {
  background: "skyblue",
  borderBottom: "1px solid red",
  'background-image':'url(https://xxxxxx.jpg)'
};
```
3. 多个类共存的操作
``` jsx
<h1 className={'class1 ' + classStr}>多个类名</h1>

let classStr = "redBg"; // ['aaa', 'bbb'].join(' '); 只能是字符串传进去
let element2 = (
  <div>
    {/* 这里写注释 */}
    <h1 className={'class1 ' + classStr}>多个类名</h1>
  </div>
);
```
4. 注释  必须在括号的表达式内书写，否则报错
``` jsx
{/* 这里写注释 */}
```

## react组件
1. 函数式组件
```jsx
// 函数式组件
function childDom(props) {
  let title = <h1>我是副标题</h1>;
  let weather = props.weather ;
  // let weather = '下雨';
  // 条件判断
  let isGo = weather == '下雨' ? 'no' : 'yes';
  return (
    <div>
      <h1>hello childDom</h1>
      {title}
      <div>
        是否出门
        <span>{isGo}</span>
      </div>
    </div>
  )
}

// 引用
ReactDOM.render(
  <childDom weather="下雨" />,
  document.querySelector('#root')
);
```
2. 类组件
``` jsx
// 类组件定义
class HelloWorld extends React.Component {
  render() {
    console.log(this);
    return (
      <div>
        <h1>类组件定义 hellword</h1>
        <h1>hello: {this.props.aaa}</h1>
        <childDom weather={this.props.weather} />
      </div>
    )
  }
}

// 引用 ReactDOM 这里 一般只放一个组件，但是这个组件内可以放多个组件
ReactDOM.render(
  <HelloWorld aaa="aadsd" weather="出太阳"/>,
  document.querySelector('#root')
);
```

3. 复合组件：组件中又有其他组件，复合组件中既可以有类组件，又可以有函数组件

函数式组件 和 类组件 的区域 和 使用
- 函数式组件比较单一，一般用于静态没有交互事件内容的组件页面
- 类组件，一般又称为动态组件，那么一般会交互或则修改数据的操作

## react status
相当于 vue 的 data, 但是使用方式与vue不一样
所有数据 都要使用 `setState` 来修改

``` jsx
// 例子： 时钟
// 类组件
class Clock extends React.Component {
  constructor(props) {
    // 构造函数
    super(props);
    // 状态(数据) -> 决定视图
    // 初始化，将需要改变的数据初始化到state中
    this.state = {
      time: new Date().toLocaleTimeString()
    }
  }

  render() {
    // 同一个组件反复调用的时候，渲染函数会一直被调用，而构造函数只会调用一次
    // this.state.time = new Date().toLocaleTimeString();
    return (
      <div>
        <h1>当前时间：{this.state.time}</h1>
      </div>
    )
  }
  // 生命周期函数---组件渲染完成时调用的函数
  componentDidMount() {
    setInterval(() => {
      // this.state.time = new Date().toLocaleTimeString(); // 错误的示范
      // 正确姿势
      // 切勿直接修改state数据 ，直接修改state数据 不会重新渲染视图，需要用到this.setState才可以 
      // 通过this.setState修改完数据后，并不会立即修改DOM里面的内容，
      // react会在这个函数内所有设置状态，统一对比虚拟DOM对象，然后再统一修改。提升性能
      // 小程序也是 借鉴 react状态管理的操作 
      this.setState({
        time: new Date().toLocaleTimeString(),
      });
      // setState是异步的，react里明确提醒别在setState之后马上调用数据，
      // 如果想马上使用数据，建议使用callback
      // setState是可以传2个参数，第一个是状态值，第二个是回调函数
      // 在回调函数里可以拿到最新的值 
    }, 1000);
  }
}

ReactDOM.render(
  <Clock />,
  document.querySelector('#root')
);
```

**例子react 实现 tab切换**
``` css
/* tab.css */
.content {
  display: none;
}
.content.active{
  display: block;
}
```
``` jsx
import './css/tab.css';

// 类组件
class Tab extends React.Component {
  constructor(props) {
    super(props);

    // 设置 状态 数据
    this.state = {
      c1: 'content active',
      c2: 'content' 
    }
    // this 不会默认绑定 类中的办法，需要手动绑定下
    this.clickEvent = this.clickEvent.bind(this);
  }

  clickEvent(e) {
    console.log('click');
    console.log(e.target.dataset.index);
    let index = e.target.dataset.index;
    if(index === '1') {
      this.setState({
        c1: 'content active',
        c2: 'content'
      });
    } else {
      this.setState({
        c1: 'content',
        c2: 'content active'
      });
    }
  }

  render() {
    return (
      <div>
      {/* 自定义属性 */}
        <button data-index="1" onClick={this.clickEvent}>内容一</button>
        <button data-index="2" onClick={this.clickEvent}>内容二</button>
        <div className={this.state.c1}>
          <h1>内容一</h1>
        </div>
        <div className={this.state.c2}>
          <h1>内容二</h1>
        </div>
      </div>
    )
  }
}

ReactDOM.render(
  <Tab />,
  document.querySelector('#root')
);
```

## react父传子数据传递
**Props**
父传递给子组件数据，单向流动，父的数据变化，子的数据也会变化。
不能子传递给父。

传过来的子组件数据不允许变化。props的传值可以是任意的

props 可以设置默认值
``` jsx
HelloMessage.defaultProps = { name: 'dega', msg: 'updateSuccess'}
```
注意：props 可以传递函数，props可以传递父元素的函数，就可以去修改父元素的state，从而达到 传递数据给父元素
``` css
/* props01.css  例子：父传子 */
.content {
  width: 400px;
  height: 400px;
  background-color: skyblue;
  display: none;
}
.content.active{
  display: block; 
}
```

``` jsx
// index.js 例子：父传子
import React from 'react';
import ReactDOM from 'react-dom';
import './css/props01.css'; 
// 在父元素中使用 state，去控制子元素props，从而达到父元素传递给子元素
class ParentCom extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      isActive: true,
    }
    this.changeShow = this.changeShow.bind(this);
  }

  render() {
    return (
      <div>
        <button onClick={this.changeShow}>控制子元素显示</button>
        <ChildCom  isActive={this.state.isActive}/> 
      </div>
    )
  }

  changeShow() {
    this.setState({
      isActive: !this.state.isActive
    });
  }
}

class ChildCom extends React.Component{
  constructor(props) {
    super(props);
  }

  render() {
    let strClass = null;
    console.log(this.props.isActive);
    // if(this.props.isActive ) {
    //   strClass = 'active';
    // } else {
    //   strClass =  '';
    // }
    strClass = this.props.isActive ? 'active' : '';

    return (
      <div className={"content  " + strClass}>
        <h1>我是子元素</h1>
      </div>
    )
  }
}

ReactDOM.render(
  <ParentCom></ParentCom>,
  document.querySelector('#root')
);
```

## react子传父数据传递
调用父元素的函数，从而操作父元素的数据，从而实现数据从子元素传递至父元素
``` jsx
// 子传父 子传递父元素的知识点
class ParentCom extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      childData: null,
    }
    // 使用这个 或者 是 在具体方法上使用箭头函数
    // this.changeShow = this.changeShow.bind(this);
  }

  // 定义一个函数 修改 childData的值
  setChildData = (data) => {
    this.setState({
      childData: data
    });
  }

  render() {
    return (
      <div>
        <h1>子元素传递给父元素的数据： {this.state.childData}</h1>
        <ChildCom  setChildData={this.setChildData}/> 
      </div>
    )
  }

  changeShow() {
    this.setState({
      isActive: !this.state.isActive
    });
  }
}

class ChildCom extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      msg: 'helloworld'
    }
    this.sendData = this.sendData.bind(this);
  }

  render() {
    return (
      <div >
        {/* 构造函数中不绑定this ，且不适用箭头函数的话，可以使用这种一次性生效的绑定方式  */}
        {/* <button onClick={this.sendData.bind(this)}>传递helloworld 给 父元素</button> */}
        <button onClick={this.sendData}>传递helloworld 给 父元素</button>
        
        {/* 这种方式后期不好维护，还是单独写出来好点，这种方法就了解一下 */}
        <button onClick={() => this.props.setChildData('直接传数据过去')}>传递helloworld 给 父元素</button>
      </div>
    )
  }

  sendData = () => {
    // console.log(this.state.msg);
    // 将子元素传递给父元素，实际上就是调用父元素传递过来的【父元素函数】
    this.props.setChildData(this.state.msg);
  }
}

ReactDOM.render(
  <ParentCom></ParentCom>,
  document.querySelector('#root')
);
```

## react 事件详情
特点
1. react事件，绑定事件的命名，驼峰命名法
2. {} 传入一个函数， 而不是字符串
```jsx
<button onClick={this.sendData}>传递helloworld 给 父元素</button>
```

事件对象： react 返回的事件对象是代理的原生的事件对象，如果想要查看事件的具体值，必须直接输出事件对象的属性。

注意：
原生，阻止默认行为时，可以直接返回 return false
react中，阻止默认 必须 `e.preventDefault();`  

react 事件 传 参数：<br/>
通过一个匿名函数进行参数传递
``` jsx
// 事件详解
class ParentCom extends React.Component{
  constructor(props) {
    super(props);
  }
  
  parentEvent = (e) => {
    console.log(e);
    // 原生 阻止默认跳转的方法是 return false
    // 现在是
    e.preventDefault();
  }

  // 传默认事件对象 e
  parentEvent1 = (msg, e) => {
    console.log(msg, e);
  }

  render() {
    return (
      <div >
        <form action="http://www.baidu.com">
          <div className="child"></div>
          <h1>helloworld</h1>
          <button onClick={this.parentEvent}>提交 </button>
        </form>

        {/* 使用es6箭头函数传递多个参数的方式 */}
        <button onClick={(e) =>{this.parentEvent1('123123', e)}}>传值 </button>
        {/* 不使用es6箭头函数传递多个参数的方式 */}
        <button onClick={function(e) {this.parentEvent1('123123', e)}.bind(this)}>传值 </button>
      </div>
    )
  }


}

ReactDOM.render(
  <ParentCom></ParentCom>,
  document.querySelector('#root')
);
```

使用箭头函数，不需要绑定this,因为 箭头函数声明的时候，它是使用外部的this,就是这个组件的this  

call 和 apply 是在调用的时候用
声明的时候是用 bind 

## react 条件渲染